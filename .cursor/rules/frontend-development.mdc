# Frontend Development Guidelines

## üö® SIMPLIFIED DEVELOPMENT APPROACH üö®

**CRITICAL: Follow SIMPLE, MAINTAINABLE patterns. NO over-engineering!**

### Development Philosophy
- **Direct implementations** over abstractions
- **Simple components** over complex component hierarchies
- **Tailwind utilities** over custom CSS or complex styling systems
- **Standard React patterns** over custom frameworks or utilities

## React TypeScript Architecture

### Tech Stack
- **Framework**: React 18 with TypeScript 5.2
- **Build Tool**: Vite with SWC for fast compilation
- **Styling**: TailwindCSS with custom components
- **UI Components**: Shadcn UI + Radix UI primitives
- **State Management**: React Query for server state
- **Package Manager**: Bun for fast dependency management

### Project Structure
- `client/src/App.tsx` - Main application component
- `client/src/pages/` - Page-level components
- `client/src/components/ui/` - Reusable UI components
- `client/src/fastapi_client/` - Auto-generated TypeScript client
- `client/src/lib/` - Utility functions and API helpers

### Component Patterns
```tsx
// Good: Simple, focused component
interface ComponentProps {
  title: string
  onAction: () => void
}

export function MyComponent({ title, onAction }: ComponentProps) {
  return (
    <div className="p-4 bg-background">
      <h1 className="text-2xl font-bold">{title}</h1>
      <Button onClick={onAction}>Action</Button>
    </div>
  )
}

// Bad: Over-engineered with unnecessary abstractions
interface AbstractComponentProps<T extends string> {
  title: T
  onAction: () => void
}

class ComponentManager<T extends string> {
  private props: AbstractComponentProps<T>
  // Complex implementation
}
```

### Styling Guidelines
- Use TailwindCSS utility classes exclusively
- Leverage Shadcn UI components for consistency
- Use `class:` for conditional styling instead of ternary operators
- Follow mobile-first responsive design principles
- **NO custom CSS or complex styling systems**
- **NO CSS-in-JS or styled-components**

### API Integration
- Use auto-generated FastAPI client from `fastapi_client/`
- Implement React Query for caching and state management
- Handle loading states and error boundaries properly
- Use proper TypeScript interfaces for API responses
- **NO custom API abstraction layers or wrappers**

### Code Quality
- Use ESLint and Prettier for code formatting
- Follow React best practices and hooks guidelines
- Implement proper accessibility features (ARIA labels, keyboard navigation)
- Use descriptive variable names with camelCase convention

### TypeScript Best Practices
- Enable strict mode in [tsconfig.json](mdc:client/tsconfig.json)
- Use proper type definitions for all props and state
- Leverage utility types (Partial, Pick, Omit) sparingly
- Implement proper error handling with type guards
- **NO complex generic types or type hierarchies**

### Forbidden Patterns
‚ùå **Complex component hierarchies** or excessive abstraction
‚ùå **Custom styling systems** or CSS-in-JS
‚ùå **Custom state management** beyond React Query
‚ùå **Custom routing solutions** or complex navigation patterns
‚ùå **Performance optimization** patterns (premature optimization)
‚ùå **Enterprise patterns** like singleton, observer, strategy, etc.

### Required Patterns
‚úÖ **Simple functional components** with clear responsibilities
‚úÖ **TailwindCSS utilities** for all styling needs
‚úÖ **React Query** for server state management
‚úÖ **Standard React hooks** (useState, useEffect, useContext)
‚úÖ **Basic error boundaries** and loading states
‚úÖ **Accessibility features** (ARIA labels, keyboard navigation)
‚úÖ **TypeScript interfaces** for props and state

### Implementation Rules
1. **One concept per component**: Each component should have a single, clear purpose
2. **Functions over classes**: Use functional components exclusively
3. **Direct API calls**: Use React Query directly, no wrapper layers
4. **Simple state management**: Use useState and useContext, avoid complex state patterns
5. **Basic testing**: Simple unit tests with basic mocking, no complex test frameworks
6. **Minimal dependencies**: Only add new dependencies if critically needed

### Code Review Questions
Before adding any code, ask yourself:
- "Is this the simplest way to solve this problem?"
- "Would a new developer understand this immediately?"
- "Am I adding abstraction for a real need or hypothetical flexibility?"
- "Can I solve this with standard React patterns or existing dependencies?"
- "Does this follow the existing patterns in the codebase?"

description: Frontend development guidelines emphasizing simple, maintainable patterns over complex abstractions
globs:
alwaysApply: false
---
